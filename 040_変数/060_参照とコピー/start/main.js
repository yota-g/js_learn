//プリミティブとオブジェクト
// データ型　文字列・数値などの異なる値の型をデータ型という。
//JSには8種類のデータ型が存在する。 2種類に分けられる
//string , boolean , number , undefined, null , symboll, BigInt　プリミティブ型
//object　オブジェクト型 プリミティブ型以外。

//プリミティブ型・・変数には値が格納される。　一度作成するとその値を変更することができない。
// immutable　不変。
// letは値を変更できるからどうなのか。
// PC上のメモリの空間とJSがどのような関係かを学ぶ。あくまでコンセプトの動き。
// 'Hello'と文字列を定義すると　メモリの最初に格納。それを変数に入れた場合　変数が''Hello'という値が格納されたアドレスの参照をしているとする。
//ここで'Bye'と文字列を定義すると、'Bye'は'Hello'とは違ったメモリの住所の格納される。
//それをaに再代入すると変数の参照先が'Bye'の住所に変更される。　これがjsの変数の再代入となるので、
//プリミティブ型では、文字列'hello'が変更されているのではなく、あくまで再代入というのはaが持っている値の参照先が変わったというだけ。

//オブジェクト型では、変数には参照が格納される。
//値を変更することができる。mutable　可変

//オブジェクトの値の保持方法。
//let a = { }はaがオブジェクトへの参照を保持しているというと認識する。
//オブジェクトへの参照はオブジェクトが実際に保持されているメモリの住所への参照を保持している。
//  そのメモリにプロパティが設定されるとオブジェクトの実態がプロパティを保持するように変更される。そして、そこにプロパティの値に'Hello'という値が設定された場合に、'Hello'が別メモリへ保存される。その情報をプロパティが保持しているオブジェクトが保持する事になる。'Hello'はメモリのどこかに値が存在していて、それへの参照をオブジェクトが保持しているだけ。
//オブジェクトの実態が変わっても変数からオブジェクトへの参照への変数aの参照は変わらないので、オブジェクトはmutableと言われる。

//オブジェクトは名前（プロパティ）と値（バリュー）をペアで管理する入れ物。
//別の言い方にすると、名前付きの参照を管理する入れものという言い方ができる。　

//参照が大切なので学ぶ。　
//データ型ではプリミティブ型とオブジェクトが存在する。
//オブジェクトは参照を名前付きで管理している入れ物である。

//参照とコピーに関して、
//プリミティブ値のコピー　
// let a = 'hello';
//この時変数aはhelloという値の参照を保持している。
//それをbに代入した場合、
// let b = a;
// この場合は、変数aが保持しているhelloという文字列の参照を別のメモリにコピーする。
//そして、それに対して変数bから参照される。
//そして、bに再代入をした場合は、bの参照先が変更となる。
// b = 'bye';  //参照先がhelloからbyeに変更となる。
//これがプリミティブの挙動。　
//keyになるのが変数aの参照先の値自体がコピーされているということ。
//変数bの値が変更された場合は変数bの参照先が変わるだけで、aの参照先が変わることはない。
//プリミティブの値のコピーはそれぞれの値が独立して存在しているので、どちらかの値を変更してももう片方の値が変わることはない。　

//オブジェクトのコピー
// let c = { 
//   prop: 'Hello';
// }
//というようにcの変数でオブジェクトを作成して、コピーを作成した場合、はオブジェクトへの参照と連携する。
//でオブジェクトの参照がオブジェクトのプロパティを参照して、そのプロパティが値を参照する。
// let d = c;
//こうするとオブジェクトへの参照が別の値へコピーされる事になる。
//この参照が保持しているのはpropのプロパティの参照なので、コピーされた後もプロパティへの参照が保持されていて、それがdに保持される事になる。
//そうするとbのプロパティが保持している値を変更してByeにするとpropの値が変数c とdともにバリューが変更されてしまう。オブジェクトをもつ変数を他の変数に代入した場合は、どちらかが値を変えるとどちらの値も変更されるという事になる。参照先が同じため。

let a = 'hello';
let b = a;
console.log(a ,b);
b = 'Bye';
console.log(a,b);

let c = {
  prop : 'hello'
}

let d = c;
console.log(c, d);
d.prop = "bye";
console.log(c ,d);
//両方の値が変わることがわかる。
// c からコピーしたdに対して、新しいプロパティを入れるとどうなるのか。
//変数からpropがあるオブジェクトへの参照だったのが別のオブジェクトでの参照になる。
//オブジェクトの実態が変わるので、それぞれに影響することはない。
d.deb = 'See'; //これで追加すると互いに影響する。
console.log(c, d);
　
d = { newProp : 'Change'}
console.log (c ,d );
//このように設定した後の変数のオブジェクトを変更すると参照先が変わるので互いに影響しないようになる。

