//Symbolに関して、プロパティに重複を避けるために必ず一意の値を返す関数。
//プリミティブ型の値の１つでもあり値を取得するには必ず関数から値を取得。
const s = Symbol('hello');
//シンボルを取得するときには大文字でSymbolと宣言する。コンストラクター関数と違いnewはいらない。
console.log(s);
//Symbol()が表示される。これは文字列ではなく内部的に一意になるデータ構造をとっている。
//consoleで表示されるときはSymbolと表示される。
//引数には文字列を入れることができる。
//そうするとSymbol(hello)と表示され、Symbolに名前をつけることができる。
//2回宣言すると異なる値が帰ってくる。
const s2 = Symbol('hello');
console.log(s2);
console.log(s === s2);
//この結果はfalseになる。 異なる値がSymbolに格納されていることがわかる。
//あくまでSymbolの引数にとる値は、Symbolの名前をつけているだけで、同じSymbolを生成することにはならない。呼び出しごとにSymbolの値は変わってくる。
//Symbolはプリミティブの一部なので
console.log(typeof s);
//このようにするとsymbolと表示される。 どのように利用されるかを確認する。

const str = new String('Tom');
console.log(str);
//String('Tom');と表示される。そのprotoの中にSymbolのイテレーターが確認できる。
//これはオブジェクトの反復などに利用するもので、なせSymbolでプロパティに格納しているかというとこのSybolが土運輸された経緯が関係している。
//ES5で
String.prototype.iterator = function () {

}
//独自の関数の処理をしていたとすると独自に定義したプロパティがある中でJSのバージョンがES6に語って、プロトタイプのイテレータが同じようにビルトインオブジェクトに追加された場合には、競合を起こして、意図した動作にならないことが容易に考えられる。そこで考え出されたのがSymbolによる格納と取得。
//Symbolは同じ名前を設定していても異なる値が毎回帰ってくるので、シンボルにビルトインメソッドとして使用するプロパティの値を入れておけば、それを機にして自由にビルトインメソッドを設定することができるようになる。
// String.prototype[s] = function () {}
//とすればsをシンボルとしたものがプロトタイプに追加される。
//これでStringのTomを確認するとStringの部分にhelloが格納されていることを確認することができる。
//このようにするとs2を新しく追加したとしても、これは異なる値のプロパティになるのでSymbolのhelloという名前は重複しているがプロパティが異なるものとして取り扱うことができる。
//ES6へバージョンが上がるときに既存のものが問題なく稼働するようにSymbolというのが導入された。
// String.prototype[s2] = function () {
//   return 'hello' + this;
// }
//Symbolに独自のメソッドを作成する。　ビルトインオブジェクトのプロトタイ　プを拡張するのはプロトタイプ汚染といって一般的には推奨されていない。動作確認で今回を行う。開発者には好かれない。
// const tom = 'Tom';
//メソッドを呼び出すが、今回の場合は、ドット記法ではなく、シンボルを使った場合は、ブラケット記法でないといけない。
// console.log(tom[s2]());
//tom.sとトップ記法で行うとこれはトムのsというプロパティということになるので、今回はsという変数に格納されているので呼び出し方が違う。
//とすると s2のシンボルにアクセスをしてhello Tomと表示することができる。
//今回はsという変数に格納されているSymbolをオブジェクトから取得したいので[]  になり、関数を実行するので()をつける。
