//ホイスティング・・コンテキスト内で宣言した変数や関数の定義をコード実行前にメモリーに配置すること。
//宣言の巻き上げということもある。　
// function a () {
//   console.log(c);
//   var c = 1;
//   d();
//   function d () {
//     console.log('d is called');
//   }
//   console.log('a is called');
// }
// a();
//関数の呼び出しを前と後ろどちらに書いても関数を呼び出している。ブラウザを見ると、、
//それはこれが実行される前にa(); の実行前に関数がすでに定義がメモリ上に配置されている から先に呼び出していてもメモリに先に配置されているので実行される事になる。
//変数の場合は、3種類の宣言があるlet const varの確認
//var b = 0;
// console.log(b);
// var b = 0 ;
//変数定義前に変数を呼び出すとundefinedと表示される。呼び出した時点で変数がまだ設定されていないから。
//var bだけ上に持ってきてconsoleの下でbに値を入れているイメージになる。
// console.log(b);
//定義後だと数字が表示される
//jsはコードを分割して、上にvar bだけを持ってくるということはしていなくて、宣言のキーワードを見つけたらメモリにundefinedという値を設定している。
//let  を見ていく。
// let b = 0;　
//const b = 0; 
//let bとconst bをconsoleの後に入れるとエラーが出る。undefinedの処理がJSにされないため。
// 初期化されてundefinedと表示されるのはvarのみ
//これ以外にもvarとは挙動が異なるのでvarの使用は非推奨。
//constとletを使用するように。
//ホイスティングがコンテキストが生成される度に行われるので、グローバルコンテキストが生成される時に宣言部のメモリスペースが確保される。またaのコンテキストが作成される時も同じ生成が行われる。
//コンテキストが生成される度にホイスティングが実行され、宣言部がメモリスペースに展開される。
//関数の宣言は、const a = function () {}とすることで宣言できる。この場合は、関数の呼び出しを先にすると通常のconstの定義と同じでエラーになる。
//変数のホイスティングと同じになるので上で宣言することに注意。

//JSエンジンによる挙動の違い
//上記のホイスティングで確認する。
//sourcesで確認
function a () {
  let c = 1;
  console.log(c);
}
a();
//let cの部分で処理を止める(ブレイクポイントをおく)とまだそこでcが定義されていないのでエラーになると思いきや、undefinedと表示されている。
//実際コンソールでcと打つとundefinedという値が帰ってくる。
//firefoxではuninitializedと表示される。
//cにアクセスしたらerrorが出る。
//JSエンジンで実行結果が変わる可能性があるというのを頭の片隅に入れておくこと。