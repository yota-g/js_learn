import { publicFn as fn , publicVal as val} from './moduleA.js';

//importでmoduleAが読み込まれてESmodule calledが呼び出されているのがわかる。
fn();
fn();
fn();
//constの変数になっているとエラーになるが、元の値はletで変更可能。moduleでインポートするとtypeerrorが出る。これは即時関数の値を設定しようとした時と同じだがモジュールで読み込んだ値に対して、参照しようとするとエラーが出る。
//モジュールの中で参照しようとしている変数がmoduleBへインポートされた場合、変数が数字になって20という値がValにコピーされてきているだけなのでpublicValの値を変更することにはならない。
//そのためデータに不整合が起きるので、モジュールでexportしたプリミティブな値の変更はESmoduleでは許可されていない。　
// console.log( val);
// console.log( val);
console.log(val.prop ++);
console.log(val.prop ++);
console.log(val.prop ++);
fn();
//moduleAのpublicValの値をオブジェクトにするとエラーは発生しなくなる。


//変数にオブジェクトを入れた場合は、オブジェクトへの参照がコピーされるのであくまでそのオブジェクトに格納されているpropは同じ値を参照することになる。外部から参照しても、内部から参照しているプロパティの値は同じものが実行される事になるので、同時に変更される事になる。
//データはオブジェクトで管理するが、もしプリティブ型の値を外から参照したいときは、使いたい変更したい場合は、関数を通して変更する必要がある。
//publicFnにprivateValを入れることで関数を通じで値を変更することができる。
//プリティブ値の使用は注意すること。
